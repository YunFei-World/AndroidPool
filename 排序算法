时间复杂度：
    平方阶(O(n2)):             插入排序、选择排序、冒泡排序
    线性对数阶(O(nlogn2)):      快速排序、堆排序、归并排序
    (O(n1+*):（*属于0～1之间常数）希尔排序
    线性阶(O(n)):              基数排序 （还有桶排序、箱排序）

稳定性：
    稳定：  冒泡排序、插入排序、归并排序、计数排序、桶排序、基数排序
    不稳定：快速排序、希尔排序、堆排序、选择排序

额外内存占用：
    内存排序：     冒泡排序、选择排序、插入排序、希尔排序、快速排序、堆排序
    需额外内存排序：归并排序、计数排序、桶排序、基数排序

1 冒泡排序

  时间复杂度：O(n2) [O(n)~O(n2)] (已经排好序～排序正好相反)
  空间复杂度：O(1)
  排序方式：  In-place
  稳定性：    稳定
  
  
  public class BubbleSort{
    
    public void bubbleSort(int[] arr){
      boolean flag = true;
      for(int i=1; i<arr.length; i++){
        flag = true;
        for(int j=0 ;j<arr.length-i; j++){
          if(arr[j]>arr[j+1]){
            swap(arr,j,j+1);
            flag = false;
          }
        }
        
        if(flag){
          break;
        }
      }
    }
    
    public void swap(int[] arr, int i, int j){
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    
    }
    
  }

2 选择排序

  时间复杂度：O(n2) 
  空间复杂度：O(1)
  排序方式：  In-place
  稳定性：    不稳定
  
  public class SelectionSort{
    
    public void  selectionSort(int[] arr){
        for(int i =0 ; i<arr.length-1; i++){
            int min =i;
            for(int j=i; j<arr.length;j++){
                if(arr[j]<arr[min]){
                    min = j;
                }
            }
            if(i != min){
                swap(arr, i ,min)
            }
        }
    }
  }
 
3 插入排序

时间复杂度：O(n2) 【O(n)~O(n2)】  (已经有序～排序相反)
空间复杂度：O(1)
排序方式：  In-place
稳定性：    稳定

public class InsertSort{
    public void insertSort(int[] arr){
    
        for(int i=1; i< arr.length; i++){
            int temp = arr[i];
            int j = i-1;
            while(j> 0 && temp < arr[j-1]){
                arr[j] = arr[j-1];
                j--;
            }
            
            if(j != i){
                arr[j] = temp;
            }        
        }
    }
}

4 希尔排序（升级版插入排序  将序列分割为子序列进程插入排序）

时间复杂度：O(nlogn2) 【O(nlogn2)~O(nlogn2)】  (已经有序～排序相反)
空间复杂度：O(1)
排序方式：  In-place
稳定性：    不稳定
public class ShellSort{
    public void shellSort(int[] arr){
        int lengrh = arr.length;
        int temp;
        for(int step = length/2 ; step >=1 ;step/=2){
            for(int i =step; i<length; i++){
                temp = arr[i];
                int j = i - step ;
                while(j>0 && temp< arr[j]){
                    arr[j+step] = arr[j];
                    j-=step;
                }
                arr[j+step] = temp;
            }
        
        }
    }
}

5 归并排序

时间复杂度：O(nlogn) 
空间复杂度：O(n)
排序方式：  In-place
稳定性：    稳定
public class MergeSort{
    public int[] mergeSort(int[] arr){
        if(arr.length<2) return arr;
        int mid = arr.length/2;
        int[] left = Arrays.copyOfRange(arr, 0, mid);
        int[] right = Arrays.copyOfRange(arr, mid, arr.length);
        
        return merge(mergeSort(left), mergeSort(right));
    }
    
    public int[] merger(int[] left, int[] right){
        int[] result = new int[left.length+right.length];
        int i =0;
        while( left.length > 0 && right.length > 0){
            if(left[0]<= right[0]){
                result[i++] = left
            }
        }
    
    }
    
    

}




6 快速排序（找基准）

  时间复杂度：O(nlogn)   【O(nlogn)-O(n2)】（基准区间中间～基准在边界）
  空间复杂度：O(logn)
  排序方式：  In-place
  稳定性：    不稳定
public class QuickSort{
  
  private static int[] quickSort(int[] arr, int left, int right){
    if(left < right){
      int partitionIndex = partition(arr,left,right);
      quickSort(arr,left,partitionIndex-1);
      quickSort(arr,partitionIndex+1,right);
    }
    return arr;
  }
  
  private static int partition(int[] arr, int left ,int right){
    int pivot = left;
    int index = pivot + 1;
    fot(int i = index ; i<=right; i++){
      if(arr[i]<arr[pivot]){
          swap(arr, i, index);
          index++;
      }
    }
    
    swap(arr, pivot, index-1);
    return index-1;
  }

  private static void swap(int[] arr, int i,int j){
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
  
  }


}
